<!-- data_structures.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Data Structures in Python – Detailed Study Notes</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 960px;
            margin: 0 auto;
            padding: 25px;
            background: linear-gradient(to bottom, #f9fafb, #f0f4ff);
            color: #1f2937;
        }
        h1 {
            color: #1e40af;
            text-align: center;
            border-bottom: 5px solid #6366f1;
            padding-bottom: 14px;
            margin-bottom: 2.5rem;
        }
        h2 {
            color: #1d4ed8;
            background: #dbeafe;
            padding: 12px 18px;
            border-radius: 10px;
            margin: 2.5rem 0 1.2rem;
        }
        h3 {
            color: #2563eb;
            margin-top: 2rem;
        }
        pre {
            background: #1e293b;
            color: #f3f4f6;
            padding: 16px 20px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.97rem;
            box-shadow: 0 4px 14px rgba(0,0,0,0.12);
            border: 1px solid #374151;
            margin: 1.4rem 0;
        }
        code {
            background: #e5e7eb;
            padding: 3px 7px;
            border-radius: 5px;
            font-family: 'Consolas', monospace;
            color: #111827;
        }
        .tip {
            background-color: #ecfdf5;
            border-left: 5px solid #10b981;
            padding: 14px 18px;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .warning {
            background-color: #fee2e2;
            border-left: 5px solid #ef4444;
            padding: 14px 18px;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.8rem 0;
            font-size: 0.98rem;
        }
        th, td {
            border: 1px solid #d1d5db;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #4f46e5;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f3f4f6;
        }
        ul {
            margin-left: 1.4rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        .back-link {
            display: inline-block;
            margin: 3rem 0 1rem;
            padding: 12px 24px;
            background: #4f46e5;
            color: white !important;
            border-radius: 10px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .back-link:hover {
            background: #4338ca;
        }
    </style>
</head>
<body>

    <h1>Core Data Structures in Python<br><small>Detailed Study Notes</small></h1>

    <p>Python provides powerful built-in data structures that form the foundation of almost every program. Mastering lists, tuples, dictionaries, and sets — along with their operations, use cases, and performance characteristics — is essential for writing efficient and clean code.</p>

    <h2>1. Lists</h2>
    <p>Ordered, mutable sequences — the most commonly used data structure in Python.</p>

    <h3>Key Characteristics</h3>
    <ul>
        <li><strong>Mutable</strong> → can change after creation</li>
        <li><strong>Ordered</strong> → preserves insertion order, supports indexing & slicing</li>
        <li><strong>Dynamic</strong> → grows/shrinks automatically</li>
        <li><strong>Duplicates allowed</strong></li>
        <li><strong>Heterogeneous</strong> → mixed types ok</li>
    </ul>

    <h3>Creation Examples</h3>
    <pre><code># Empty list
my_list = []

# With values
scores = [85, 92, 78, 95, 'A+']

# From other iterables
chars = list("python")          # ['p', 'y', 't', 'h', 'o', 'n']
numbers = list(range(5))        # [0, 1, 2, 3, 4]</code></pre>

    <h3>Most Important Methods & Operations</h3>
    <table>
        <tr><th>Operation</th><th>Example</th><th>Result / Notes</th></tr>
        <tr><td>Access</td><td><code>lst[0]</code> / <code>lst[-1]</code></td><td>First / last item</td></tr>
        <tr><td>Slicing</td><td><code>lst[1:4:2]</code></td><td>start:end:step</td></tr>
        <tr><td>Append</td><td><code>lst.append(x)</code></td><td>Add to end (O(1) amortized)</td></tr>
        <tr><td>Insert</td><td><code>lst.insert(0, x)</code></td><td>Slow — O(n)</td></tr>
        <tr><td>Remove</td><td><code>lst.remove(value)</code></td><td>First match, O(n)</td></tr>
        <tr><td>Pop</td><td><code>lst.pop()</code> / <code>lst.pop(0)</code></td><td>Last = fast, first = slow</td></tr>
        <tr><td>Sort</td><td><code>lst.sort()</code> / <code>sorted(lst)</code></td><td>In-place vs new list</td></tr>
        <tr><td>Length</td><td><code>len(lst)</code></td><td>O(1)</td></tr>
        <tr><td>Membership</td><td><code>x in lst</code></td><td>O(n) — linear search</td></tr>
    </table>

    <div class="tip">
        <strong>Best practice:</strong> Prefer <code>append()</code> + <code>pop()</code> for stacks (LIFO).<br>
        For queues (FIFO), use <code>collections.deque</code> instead of list.pop(0).
    </div>

    <h2>2. Tuples</h2>
    <p>Immutable sequences — used when data should not change.</p>

    <h3>Key Points</h3>
    <ul>
        <li><strong>Immutable</strong> → hashable → can be dict keys / set elements</li>
        <li>Ordered, allows duplicates, supports indexing/slicing</li>
        <li>More memory efficient than lists</li>
    </ul>

    <h3>Important Patterns</h3>
    <pre><code># Single element tuple (must have comma)
singleton = (42,)

# Tuple unpacking (very common)
x, y, z = (10, 20, 30)

# Return multiple values from function
def get_person():
    return "Megan", 25, "Bengaluru"

name, age, city = get_person()</code></pre>

    <div class="tip">
        <strong>Use tuples when:</strong> data is constant, returning multiple values, dictionary keys, or you want slight performance gain.
    </div>

    <h2>3. Dictionaries (dict)</h2>
    <p>Key-value mappings with fast lookups (hash table).</p>

    <h3>Since Python 3.7</h3>
    <p>Dictionaries preserve insertion order (officially guaranteed).</p>

    <h3>Common Operations Table</h3>
    <table>
        <tr><th>Operation</th><th>Example</th><th>Time Complexity</th></tr>
        <tr><td>Get</td><td><code>d[key]</code> / <code>d.get(key, default)</code></td><td>O(1) avg</td></tr>
        <tr><td>Set / Update</td><td><code>d[key] = value</code></td><td>O(1) avg</td></tr>
        <tr><td>Delete</td><td><code>del d[key]</code> / <code>d.pop(key)</code></td><td>O(1) avg</td></tr>
        <tr><td>Membership (key)</td><td><code>key in d</code></td><td>O(1) avg</td></tr>
        <tr><td>Keys / Values / Items</td><td><code>list(d.keys())</code></td><td>O(n)</td></tr>
    </table>

    <div class="tip">
        <strong>Modern pattern (Python 3.6+):</strong><br>
        <code>for name, score in student_scores.items():</code><br>
        very clean iteration over key-value pairs.
    </div>

    <h2>4. Sets</h2>
    <p>Unordered collections of <strong>unique</strong>, immutable elements — extremely fast membership testing.</p>

    <h3>Key Operations</h3>
    <table>
        <tr><th>Operation</th><th>Syntax</th><th>Example Result</th></tr>
        <tr><td>Union</td><td><code>a | b</code> or <code>a.union(b)</code></td><td>all elements</td></tr>
        <tr><td>Intersection</td><td><code>a & b</code></td><td>common elements</td></tr>
        <tr><td>Difference</td><td><code>a - b</code></td><td>in a but not in b</td></tr>
        <tr><td>Symmetric Difference</td><td><code>a ^ b</code></td><td>exclusive elements</td></tr>
        <tr><td>Membership</td><td><code>x in myset</code></td><td>O(1) average</td></tr>
    </table>

    <div class="tip">
        <strong>Most common real-world use:</strong><br>
        <code>unique_users = set(all_logins)</code><br>
        <code>admins = set(['alice', 'bob'])</code><br>
        <code>non_admins = unique_users - admins</code>
    </div>

    <h2>Quick Comparison Table</h2>
    <table>
        <tr>
            <th>Type</th>
            <th>Mutable?</th>
            <th>Ordered?</th>
            <th>Duplicates?</th>
            <th>Indexed?</th>
            <th>Hashable?</th>
            <th>Best For</th>
        </tr>
        <tr><td>List</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>Ordered sequences</td></tr>
        <tr><td>Tuple</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Fixed data, keys</td></tr>
        <tr><td>Dict</td><td>Yes</td><td>Yes (3.7+)</td><td>No (keys)</td><td>By key</td><td>No</td><td>Mappings, lookups</td></tr>
        <tr><td>Set</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Uniqueness, membership</td></tr>
    </table>

    <h2>Bonus: collections Module Highlights</h2>
    <ul>
        <li><code>defaultdict</code> → auto-create missing keys</li>
        <li><code>Counter</code> → counting hashable objects (very useful)</li>
        <li><code>deque</code> → fast append/pop from both ends</li>
        <li><code>namedtuple</code> → lightweight object with named fields</li>
    </ul>

    <p style="text-align: center;">
        <a href="Topics.html" class="back-link">← Back to Topics</a>
    </p>

</body>
</html>
